%matplotlib inline
import re
import os

def extractop(op,name):
    
    li=['aad', 'aam', 'adc', 'add', 'addpd', 'addps', 'addsd', 'align',
        'and', 'andnps', 'andpd', 'andps', 'arpl', 'assume', 'bound', 'bsf',
        'bsr', 'bswap', 'bt', 'btc', 'btr', 'bts', 'call', 'cmova',
        'cmovb', 'cmovbe', 'cmovg', 'cmovge', 'cmovl', 'cmovle', 'cmovnb', 'cmovns',
        'cmovnz', 'cmovs', 'cmovz', 'cmp', 'cmpeqsd', 'cmpltpd', 'cmps', 'cmpxchg',
        'db', 'dd', 'dec', 'div', 'divsd', 'dq', 'dt', 'dw',
        'end', 'endp', 'enter', 'fadd', 'faddp', 'fbld', 'fbstp', 'fcmovb',
        'fcmovbe', 'fcmove', 'fcmovnb', 'fcmovnbe', 'fcmovne', 'fcmovnu', 'fcmovu', 'fcom',
        'fcomi', 'fcomip', 'fcomp', 'fdiv', 'fdivp', 'fdivr', 'fdivrp', 'ffree',
        'ffreep', 'fiadd', 'ficom', 'ficomp', 'fidiv', 'fidivr', 'fild', 'fimul',
        'fist', 'fistp', 'fisttp', 'fisub', 'fisubr', 'fld', 'fldcw', 'fldenv',
        'fmul', 'fmulp', 'fnsave', 'fnstcw', 'fnstenv', 'fnstsw', 'frstor', 'fsave',
        'fst', 'fstcw', 'fstp', 'fstsw', 'fsub', 'fsubp', 'fsubr', 'fsubrp',
        'fucom', 'fucomi', 'fucomip', 'fucomp', 'fxch', 'hnt', 'hostshort',
        'ht', 'idiv', 'imul', 'in', 'inc', 'include', 'int', 'ja', 'jb', 'jbe',
        'jecxz', 'jg', 'jge', 'jl', 'jle', 'jmp', 'jnb', 'jno', 'jnp', 'jns',
        'jnz', 'jo', 'jp', 'js', 'jz', 'ldmxcsr', 'lds', 'lea', 'les', 'lock',
        'lods', 'loop', 'loope', 'loopne', 'mov', 'movapd', 'movaps', 'movd',
        'movdqa', 'movhps', 'movlpd', 'movlps', 'movq', 'movs', 'movsd', 'movss',
        'movsx', 'movups', 'movzx', 'mul', 'mulpd', 'mulps', 'mulsd', 'neg',
        'nop', 'not', 'offset', 'or', 'orpd', 'orps', 'out', 'outs', 'paddb',
        'paddd', 'paddq', 'paddsb', 'paddsw', 'paddusb', 'paddusw', 'paddw',
        'pand', 'pandn', 'pavgb', 'pcmpeqb', 'pcmpeqd', 'pcmpeqw', 'pcmpgtb',
        'pcmpgtd', 'pcmpgtw', 'pextrw', 'piconinfo', 'pinsrw', 'pmaddwd',
        'pmaxsw', 'pmulhw', 'pmullw', 'pop', 'por', 'pperrinfo', 'proc',
        'pshufd', 'pshufw', 'pslld', 'psllq', 'psllw', 'psrad', 'psraw',
        'psrld', 'psrlq', 'psrlw', 'psubb', 'psubd', 'psubq', 'psubsb',
        'psubsw', 'psubusb', 'psubusw', 'psubw', 'public', 'punpckhbw',
        'punpckhdq', 'punpckhwd', 'punpcklbw', 'punpckldq', 'punpcklwd',
        'push', 'pxor', 'rcl', 'rcpps', 'rcr', 'rep', 'repe', 'repne',
        'retf', 'retfw', 'retn', 'retnw', 'rgsabound', 'rol', 'ror', 'sal',
        'sar', 'sbb', 'scas', 'segment', 'setb', 'setbe', 'setl', 'setle',
        'setnb', 'setnbe', 'setnl', 'setnle', 'setns', 'setnz', 'seto',
        'sets', 'setz', 'shl', 'shld', 'shr', 'shrd', 'shufps', 'sldt',
        'stmxcsr', 'stos', 'sub', 'subpd', 'subps', 'subsd', 'test',
        'ucomisd', 'unicode', 'xadd', 'xchg', 'xlat', 'xor', 'xorpd', 'xorps']

    # op = list()
    with open(name,'r',encoding = "utf-8",errors="ignore") as fin:
        for i in fin:
            s = i.split(' ')
            for k in s:
                if k in li:
                  op.append(k)
    # print(op)
    return op     
 

def count_bytes(name):
  count = 0
  byte = list()
  bytecount = 100
  # print(bytecount*100)
  with open(name,'r') as fin:
        # while count<= bytecount*100:
          for line in fin:
            xx=line.split()
            for i in xx[1:]:
                  if count == (256*256):
                    break
                  elif i !='??':
                    byte.append(int(i,16))
                    
                    # print(byte.append(int(i,16)))
                  else:
                    byte.append("00")
                  count += 1
                 
  # print('byte len',len(byte))
  return byte   


def count_bytes_hex(name,bytecount):
  count = 0
  byte = list()
  with open(name,'r') as fin:
        # while count <= (bytecount*100):
          for line in fin:
            xx=line.split()
            for i in xx[1:]:
                  if count == (bytecount*100):
                    break
                  elif i !='??':
                    byte.append(i)
                    
                    # print(byte.append(int(i,16)))
                  else:
                    byte.append("00")
                  count += 1   
  # print('byte hex',len(byte))
  return byte              



def word2vec_op(name,array): 
    
    file =  open('/content/asmopcode.txt','r')
    str = file.read()
    # text = re.sub(r'\[[0-9]*\]',' ',str)
    text = re.sub(r'\s+',' ',str)
    text = text.lower()
    text = re.sub(r'\d',' ',text)
    text = re.sub(r'\s+',' ',text)
    
    sentences = nltk.sent_tokenize(text)

    sentences = [nltk.word_tokenize(sentence) for sentence in sentences]
    model = Word2Vec(sentences, min_count=1,size=256 ,workers=3, window =3, sg = 0)
    # print(model)
    words = list(model.wv.vocab)
    # print(words)

    result1 = model.wv.vectors
    # print(result1)
    file.close()
    # print(result1.shape)
    return result1


def word2vec_byte(): 
    file =  open('/content/byte.txt','r')
    str = file.read()
    # print(str)
    # text = re.sub(r'\[[0-9]*\]',' ',str)
    text = re.sub(r'\s+',' ',str)
    text = text.lower()
    # text = re.sub(r'\d',' ',text)
    text = re.sub(r'\s+',' ',text)
    sentences = nltk.word_tokenize(str)

    sentences = [nltk.word_tokenize(sentence) for sentence in sentences]
    # print('sentences',sentences)
    # if(len(sentences)>0):
    model = Word2Vec(sentences, min_count=1,size= 256,workers=3, window =3, sg = 0)
      # print(model)
    words = list(model.wv.vocab)
      # print(words)

    result1 = model.wv.vectors
    # print('bytevec',result1)
    file.close()
    return result1
    # # print(result1.shape)
    # # else:
    # #   pass
  


# def mat_convert(array):
#     if(len(array)) < 100:
#       hori_array = np.zeros((100-len(array),100),dtype = int)
#     res_array = np.concatenate((array,hori_array),axis = 0)
#     # print('res_array',res_array)
#     return res_array

def mat_convert(array):
    if(len(array)) < 256:
      hori_array = np.zeros((256-len(array),len(array[0])),dtype = int)
      array = np.concatenate((array,hori_array),axis = 0)
    if(len(array[0])) < 256:
      vert_array = np.zeros((256,(256-len(array[0]))),dtype = int)
      array = np.concatenate((array,vert_array),axis = 1)
    # print('res_array',res_array)
    return array


def direct_conv():
      directory = '/content/drive/MyDrive/malware/ms_dataset/train_set'
      files = os.listdir(directory)
      #print(files[0].split("."))
      sorted_files = sorted(files)
      bytecount=0
      count = 3000
      no_op = list()
      for i in range(3000, 5000, 2):
           print(sorted_files[i])
           asmfile = directory+"/"+sorted_files[i]
           bytefile = directory+"/"+sorted_files[i+1] 
           op = list()
           opcode = extractop(op,asmfile)
           array = list()
          #  print(len(op))
           if(len(opcode) > 0):
              f = open('asmopcode.txt', 'w')
              for item in opcode:
                      f.write("%s " % item)
              f.close()
              #  print(type(f))       
              word_array = word2vec_op(f,array)
              
              word_array = word_array - word_array.min()
              word_array = word_array/word_array.max()
              word_array = (word_array*255).astype(np.uint8)
              bytecount = len(word_array)
              #  print('len',bytecount)
              #  print('wordarray',word_array.shape)
              hex_array = count_bytes_hex(bytefile,bytecount)
              #  print('bytehex',hex_array)
              #  print('bytecount',bytecount)
              #  print(len(hex_array))

              f = open('byte.txt', 'w')
              for item in hex_array:
                      f.write("%s " % item)
              f.close()
              #  print(sorted_files[i+1])   
              word_array1 = word2vec_byte()
              #  if(len(word_array1))
              #  print(word_array1)
              #  print('word array',len(word_array1))
              word_array1 = word_array1 - word_array1.min()
              word_array1 = word_array1/word_array1.max()
              word_array1 = (word_array1*255).astype(np.uint8)
              
              byte_array = count_bytes(bytefile)
              #  print(len(byte_array))
              if(len(byte_array) < 65536):
                    n = 65536-len(byte_array)
                    while(n > 0):
                      byte_array.append(0)
                      n -= 1
              byte_array1 = np.reshape(byte_array,(256,256)).astype(np.int)
              
              pad_op = mat_convert(word_array)
              #  print('padop',pad_op.shape)
              pad_byte = mat_convert(word_array1)
              #  print('padbyte',pad_byte.shape)

              #  print(pad_op.shape)
              #  print(pad_byte.shape) 

              final1 = np.dstack([byte_array1,pad_byte,pad_op])
              #  final1 = np.dstack([byte_array1,word_array1,word_array])
              im1 = Image.fromarray((final1).astype(np.uint8))
              plt.imshow(im1)
              im1.save('/content/drive/MyDrive/rgbimages/' + sorted_files[i] + '.png', "PNG")
              count += 1
              print(count)
           else:
              continue  




if __name__ == '__main__':
  direct_conv()
